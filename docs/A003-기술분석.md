# A003-기술분석: 핵심 기술 스택 심층 분석

**버전:** 1.0  
**작성일:** 2026-02-20  

---

## 1. Obsidian을 지식그래프로 사용하는 방법

### 1.1 왜 Obsidian이 최적의 개인용 지식그래프인가

기업들이 수백억을 들여 온톨로지 시스템을 구축하지만, 개인 수준에서는 Obsidian이 이를 대체할 수 있다.

| 지식그래프 요소 | Obsidian 매핑 |
|----------------|--------------|
| **노드 (Node)** | 각 마크다운 파일 (.md) |
| **엣지 (Edge)** | `[[위키링크]]`, YAML의 `related:` 등 |
| **속성 (Property)** | YAML frontmatter (tags, type, created...) |
| **시각화** | Graph View (내장) |
| **쿼리** | Dataview 플러그인 (SQL-like) |

### 1.2 YAML Frontmatter 활용

```yaml
---
type: concept
tags: [ai, graphrag, knowledge-management]
related: 
  - "[[NetworkX]]"
  - "[[벡터 임베딩]]"
created: 2026-02-20
source: "[[YouTube_평범한사업가_74]]"
importance: high
---
```

**추출 가능한 정보:**
- `type` → 엔티티 분류 (Person, Concept, Project...)
- `related` → 명시적 관계 (엣지)
- `tags` → 카테고리/도메인 분류
- `source` → 출처 추적 (provenance)

### 1.3 [[위키링크]]를 통한 암묵적 관계

```markdown
# GraphRAG 개념 정리

[[팔란티어]]의 사례에서 보듯, [[온톨로지]]와 [[지식그래프]]의 결합은
단순 [[벡터 검색]]보다 훨씬 풍부한 맥락을 제공한다.

이를 개인 수준에서 구현하려면 [[Obsidian]]과 [[NetworkX]]를 활용할 수 있다.
```

**파싱 결과:** `GraphRAG` 노드가 `팔란티어`, `온톨로지`, `지식그래프`, `벡터 검색`, `Obsidian`, `NetworkX`와 연결

### 1.4 Dataview 쿼리 예시

```dataview
TABLE type, importance, created
FROM #ai
WHERE type = "concept"
SORT importance DESC
```

---

## 2. NetworkX 인메모리 그래프

### 2.1 왜 NetworkX인가 (not Neo4j)

| | Neo4j | NetworkX |
|---|---|---|
| **서버** | 별도 DB 서버 필요 | 인메모리, 서버 없음 |
| **설치** | Docker/설치 필요 | `pip install networkx` |
| **데이터 동기화** | Obsidian → Neo4j 파이프라인 | 볼트에서 직접 빌드 |
| **규모** | 수백만 노드 | 수만 노드 (개인 충분) |
| **비용** | 호스팅 비용 | 무료 |
| **Source of Truth** | Neo4j가 됨 (이중화) | Obsidian이 유일한 진실 |

**결론:** 개인 볼트는 수천~수만 노트 규모 → NetworkX로 충분. 볼트가 유일한 source of truth 유지.

### 2.2 볼트 파싱 → 그래프 빌드 파이프라인

```python
import networkx as nx
from pathlib import Path
import yaml
import re

def build_graph(vault_path: str) -> nx.DiGraph:
    G = nx.DiGraph()
    vault = Path(vault_path)
    
    for md_file in vault.rglob("*.md"):
        note_name = md_file.stem
        
        # 1. YAML frontmatter 파싱
        content = md_file.read_text(encoding='utf-8')
        metadata = extract_frontmatter(content)
        
        # 2. 노드 추가 (속성 포함)
        G.add_node(note_name, **metadata)
        
        # 3. [[위키링크]] 파싱 → 엣지 추가
        links = re.findall(r'\[\[([^\]|]+?)(?:\|[^\]]+?)?\]\]', content)
        for link in links:
            G.add_edge(note_name, link, type="wiki_link")
        
        # 4. YAML related 필드 → 명시적 관계
        for related in metadata.get('related', []):
            target = related.strip('[]').replace('[[', '').replace(']]', '')
            G.add_edge(note_name, target, type="explicit_relation")
    
    return G
```

### 2.3 그래프 탐색 알고리즘

| 알고리즘 | 용도 | 예시 |
|----------|------|------|
| **BFS/DFS** | N-hop 이웃 탐색 | "이 개념과 2단계 이내 연결된 모든 노트" |
| **Shortest Path** | 두 개념 간 최단 연결 | "GraphRAG와 팔란티어는 어떻게 연결되나?" |
| **PageRank** | 중요 노드 식별 | "내 볼트에서 가장 핵심적인 개념 Top 10" |
| **Community Detection** | 클러스터 발견 | "자연스럽게 형성된 지식 그룹은?" |
| **Centrality** | 허브 노드 식별 | "가장 많이 연결된 '허브' 개념은?" |

### 2.4 성능 고려사항

| 볼트 규모 | 노트 수 | 그래프 빌드 | 메모리 |
|----------|---------|-----------|--------|
| 소형 | ~500 | <1초 | ~10MB |
| 중형 | ~5,000 | ~3초 | ~50MB |
| 대형 | ~50,000 | ~30초 | ~500MB |

**최적화 전략:**
- 증분 빌드: 변경된 파일만 업데이트 (파일 해시 캐시)
- Lazy loading: 쿼리에 필요한 서브그래프만 로드
- 임베딩 캐시: 변경 없는 노트는 재계산 안 함

---

## 3. GraphRAG 구현 방식 비교

### 3.1 후보 프레임워크

| 프레임워크 | 특징 | Mnemo 적합도 |
|-----------|------|-------------|
| **Microsoft GraphRAG** | 자동 엔티티 추출, 커뮤니티 요약, 글로벌/로컬 검색 | △ 과도하게 무거움, LLM 비용 높음 |
| **LightRAG** | 경량, 빠른 구축, 그래프+벡터 하이브리드 | ✅ 좋은 참고, 가벼움 |
| **nano-graphrag** | 미니멀 구현, 교육용 | ✅ 참고용으로 최적 |
| **커스텀 (Mnemo)** | Obsidian-native 최적화 | ✅ 최종 선택 |

### 3.2 Mnemo GraphRAG 아키텍처

```
질문: "GraphRAG와 관련된 프로젝트에서 배운 교훈은?"

Step 1: 질문 임베딩 생성
Step 2: 벡터 유사도 Top-K 노트 검색
Step 3: 검색된 노트에서 그래프 확장 (1-2 hop)
Step 4: 확장된 서브그래프에서 관련 노트 수집
Step 5: 컨텍스트 구성 (노트 내용 + 관계 정보)
Step 6: LLM에 컨텍스트 + 질문 전달 → 답변 생성
```

### 3.3 벡터 + 그래프 하이브리드 검색

```python
def hybrid_search(query: str, G: nx.DiGraph, embeddings: dict, top_k=5):
    # 1. 벡터 유사도 검색
    query_embedding = embed(query)
    vector_results = cosine_similarity_search(query_embedding, embeddings, top_k)
    
    # 2. 그래프 확장 (1-2 hop 이웃)
    expanded = set()
    for node, score in vector_results:
        expanded.add(node)
        for neighbor in nx.ego_graph(G, node, radius=2):
            expanded.add(neighbor)
    
    # 3. 확장된 노드들을 관련도 재순위화
    ranked = rerank(query, expanded, G, embeddings)
    
    # 4. 서브그래프 컨텍스트 구성
    context = build_context(ranked[:top_k], G)
    
    return context
```

**왜 하이브리드가 벡터만보다 나은가:**
- 벡터만: "GraphRAG"를 검색하면 직접 언급된 노트만 반환
- 하이브리드: "GraphRAG" → 연결된 "팔란티어" → "온톨로지" → "MAIOSS에서 적용한 경험" 까지 탐색

---

## 4. Obsidian 플러그인 개발

### 4.1 기술 스택

| 항목 | 기술 |
|------|------|
| **언어** | TypeScript |
| **API** | Obsidian Plugin API |
| **빌드** | esbuild |
| **UI** | Obsidian의 설정 패널 + 커스텀 뷰 |

### 4.2 플러그인 구조

```
mnemo-obsidian-plugin/
├── main.ts           # 엔트리포인트
├── src/
│   ├── parser.ts     # 볼트 파싱 (YAML + 위키링크)
│   ├── graph.ts      # NetworkX ↔ JS 브릿지 또는 순수 TS 그래프
│   ├── search.ts     # GraphRAG 쿼리 인터페이스
│   ├── views/
│   │   ├── QueryView.ts    # 인라인 질의 UI
│   │   └── GraphView.ts    # 관계 시각화
│   └── settings.ts   # 설정 (API 키, 모델 선택)
├── manifest.json
└── package.json
```

### 4.3 대안: Python 백엔드 + 플러그인 프론트

플러그인 내에서 무거운 연산(그래프 빌드, 임베딩)을 하면 Obsidian이 느려질 수 있음.

```
Obsidian Plugin (TypeScript) ←→ Python 서버 (localhost)
    UI/질의 인터페이스             그래프빌드/임베딩/RAG
```

Python 서버를 OpenClaw 스킬로 관리하면 별도 프로세스 관리도 자동화.

---

## 5. OpenClaw 에이전트 연동

### 5.1 연동 방식

| 기능 | OpenClaw 활용 |
|------|-------------|
| **자동 수집** | 크론 스킬 → RSS/웹 클리핑 → 볼트에 노트 생성 |
| **그래프 빌드** | 크론 → Python 파서 실행 → 그래프 캐시 갱신 |
| **질의 응답** | 사용자 메시지 → GraphRAG 검색 → 답변 |
| **복습 에이전트** | 크론 → 망각 곡선 기반 노트 선택 → 퀴즈/요약 전송 |
| **브리핑** | 크론 → 일일 요약 생성 → TTS → Discord/앱 전송 |

### 5.2 스킬 구조 예시

```
skills/mnemo/
├── SKILL.md
├── collect.py     # RSS/웹 수집
├── build-graph.py # 그래프 빌드
├── search.py      # GraphRAG 검색
└── review.py      # 복습 에이전트
```

---

## 6. 기술적 리스크 및 해결 방안

| 리스크 | 해결 방안 |
|--------|----------|
| **대규모 볼트 파싱 속도** | 증분 빌드 (파일 해시 비교), 백그라운드 처리 |
| **LLM API 비용** | Ollama 로컬 모델 대안, 임베딩 캐시, 배치 처리 |
| **Obsidian 플러그인 성능** | 무거운 연산은 Python 백엔드로 분리 |
| **YAML 비표준 사용** | 스키마 검증기 + 자동 수정 도구 제공 |
| **Windows/Mac/Linux 호환** | Python + Node 크로스플랫폼, 경로 추상화 |
| **위키링크 파싱 정확도** | Obsidian 공식 파서 참조, alias 지원 (`[[원본\|별칭]]`) |

---

*Created: 2026-02-20 by MAIBOT*
